{"ast":null,"code":"export function timestampToReadableDate(timestamp) {\n  // Convert the timestamp (in ISO 8601 format) to a Date object\n  const date = new Date(timestamp);\n\n  // Define options for formatting the date\n  const options = {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: 'numeric',\n    minute: 'numeric'\n  };\n\n  // Format the date and return it as a readable string\n  return date.toLocaleDateString(undefined, options);\n}\nexport function getAverage(data, frame) {\n  if (!data || data.length === 0) {\n    return []; // Return an empty array if the data is empty or undefined.\n  }\n\n  // Parse the timestamp strings into Date objects for easier date manipulation.\n  data = data.map(entry => ({\n    ...entry,\n    timestamp: new Date(entry.timestamp)\n  }));\n\n  // Calculate the time frame (in milliseconds) based on the user's selection.\n  let timeFrame;\n  switch (frame) {\n    case \"Daily\":\n      timeFrame = 24 * 60 * 60 * 1000; // 1 day\n      break;\n    case \"Weekly\":\n      timeFrame = 7 * 24 * 60 * 60 * 1000; // 7 days\n      break;\n    case \"Monthly\":\n      // This is a simplified calculation for an \"average\" month. You may need more accurate calculations based on the specific month.\n      timeFrame = 30 * 24 * 60 * 60 * 1000; // 30 days (approximate)\n      break;\n    case \"Hourly\":\n      timeFrame = 60 * 60 * 1000; // 1 hour\n      break;\n    default:\n      throw new Error(\"Invalid time frame\");\n  }\n\n  // Initialize variables for the aggregation process.\n  let currentFrameStart = data[0].timestamp.getTime();\n  let frameData = [];\n  let aggregatedData = [];\n\n  // Iterate through the data to calculate averages.\n  for (let entry of data) {\n    if (entry.timestamp.getTime() - currentFrameStart <= timeFrame) {\n      // Data within the current frame; add it to the frameData array.\n      frameData.push(entry);\n    } else {\n      // Data outside the current frame; calculate the average and push it to aggregatedData.\n      if (frameData.length > 0) {\n        const frameTimestamp = new Date(currentFrameStart + timeFrame / 2); // Use the midpoint of the frame as the timestamp.\n        const averageEntry = {\n          timestamp: frameTimestamp\n        };\n\n        // Calculate the average for each parameter.\n        for (let param of Object.keys(frameData[0])) {\n          if (param !== \"timestamp\") {\n            const total = frameData.reduce((acc, dataEntry) => acc + dataEntry[param], 0);\n            averageEntry[param] = total / frameData.length;\n          }\n        }\n        aggregatedData.push(averageEntry);\n      }\n\n      // Move to the next time frame.\n      currentFrameStart += timeFrame;\n      frameData = [entry];\n    }\n  }\n\n  // Ensure the last frame is processed.\n  if (frameData.length > 0) {\n    const frameTimestamp = new Date(currentFrameStart + timeFrame / 2);\n    const averageEntry = {\n      timestamp: frameTimestamp\n    };\n    for (let param of Object.keys(frameData[0])) {\n      if (param !== \"timestamp\") {\n        const total = frameData.reduce((acc, dataEntry) => acc + dataEntry[param], 0);\n        averageEntry[param] = total / frameData.length;\n      }\n    }\n    aggregatedData.push(averageEntry);\n  }\n  return aggregatedData;\n}","map":{"version":3,"names":["timestampToReadableDate","timestamp","date","Date","options","year","month","day","hour","minute","toLocaleDateString","undefined","getAverage","data","frame","length","map","entry","timeFrame","Error","currentFrameStart","getTime","frameData","aggregatedData","push","frameTimestamp","averageEntry","param","Object","keys","total","reduce","acc","dataEntry"],"sources":["/home/labber/Dev/chemical-plant-dashboard/client/src/services/Time/time.js"],"sourcesContent":["export function timestampToReadableDate(timestamp) {\r\n  // Convert the timestamp (in ISO 8601 format) to a Date object\r\n  const date = new Date(timestamp);\r\n\r\n  // Define options for formatting the date\r\n  const options = {\r\n    year: 'numeric',\r\n    month: '2-digit',\r\n    day: '2-digit',\r\n    hour: 'numeric',\r\n    minute: 'numeric',\r\n  };\r\n\r\n  // Format the date and return it as a readable string\r\n  return date.toLocaleDateString(undefined, options);\r\n}\r\n\r\nexport function getAverage(data, frame) {\r\n  if (!data || data.length === 0) {\r\n    return []; // Return an empty array if the data is empty or undefined.\r\n  }\r\n\r\n  // Parse the timestamp strings into Date objects for easier date manipulation.\r\n  data = data.map((entry) => ({\r\n    ...entry,\r\n    timestamp: new Date(entry.timestamp),\r\n  }));\r\n\r\n  // Calculate the time frame (in milliseconds) based on the user's selection.\r\n  let timeFrame;\r\n  switch (frame) {\r\n    case \"Daily\":\r\n      timeFrame = 24 * 60 * 60 * 1000; // 1 day\r\n      break;\r\n    case \"Weekly\":\r\n      timeFrame = 7 * 24 * 60 * 60 * 1000; // 7 days\r\n      break;\r\n    case \"Monthly\":\r\n      // This is a simplified calculation for an \"average\" month. You may need more accurate calculations based on the specific month.\r\n      timeFrame = 30 * 24 * 60 * 60 * 1000; // 30 days (approximate)\r\n      break;\r\n    case \"Hourly\":\r\n      timeFrame = 60 * 60 * 1000; // 1 hour\r\n      break;\r\n    default:\r\n      throw new Error(\"Invalid time frame\");\r\n  }\r\n\r\n  // Initialize variables for the aggregation process.\r\n  let currentFrameStart = data[0].timestamp.getTime();\r\n  let frameData = [];\r\n  let aggregatedData = [];\r\n\r\n  // Iterate through the data to calculate averages.\r\n  for (let entry of data) {\r\n    if (entry.timestamp.getTime() - currentFrameStart <= timeFrame) {\r\n      // Data within the current frame; add it to the frameData array.\r\n      frameData.push(entry);\r\n    } else {\r\n      // Data outside the current frame; calculate the average and push it to aggregatedData.\r\n      if (frameData.length > 0) {\r\n        const frameTimestamp = new Date(currentFrameStart + timeFrame / 2); // Use the midpoint of the frame as the timestamp.\r\n        const averageEntry = { timestamp: frameTimestamp };\r\n\r\n        // Calculate the average for each parameter.\r\n        for (let param of Object.keys(frameData[0])) {\r\n          if (param !== \"timestamp\") {\r\n            const total = frameData.reduce((acc, dataEntry) => acc + dataEntry[param], 0);\r\n            averageEntry[param] = total / frameData.length;\r\n          }\r\n        }\r\n\r\n        aggregatedData.push(averageEntry);\r\n      }\r\n\r\n      // Move to the next time frame.\r\n      currentFrameStart += timeFrame;\r\n      frameData = [entry];\r\n    }\r\n  }\r\n\r\n  // Ensure the last frame is processed.\r\n  if (frameData.length > 0) {\r\n    const frameTimestamp = new Date(currentFrameStart + timeFrame / 2);\r\n    const averageEntry = { timestamp: frameTimestamp };\r\n\r\n    for (let param of Object.keys(frameData[0])) {\r\n      if (param !== \"timestamp\") {\r\n        const total = frameData.reduce((acc, dataEntry) => acc + dataEntry[param], 0);\r\n        averageEntry[param] = total / frameData.length;\r\n      }\r\n    }\r\n\r\n    aggregatedData.push(averageEntry);\r\n  }\r\n\r\n  return aggregatedData;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}